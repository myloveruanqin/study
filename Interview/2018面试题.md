## js 中如何检测一个变量是 String 类型

```
functiton isString(obj) {
  return typeof(obj) === "string" ? true : false;
}
```

```
function isString(obj) {
  return obj.constructor === String ? true : false
}
```

```
function isString(obj) {
  return Object.prototype.toString.call(obj) === "[object String]" ? true : false
}
```

## 请用 js 去除字符串空格

1.  使用 replace 正则匹配的方法

去除所有空格: str = str.replace(/\s*/g, '');
去除两头空格：str = str.replace(/^\s*|\s*$/g, '');
去除左空格：str = str.replace(/^\s*/, '');
取出右空格：str = str.replace(/(\s\*$)/g, '');

str 为要去除空格的字符串

```
var str = ' 23  23 ';
var str2 = str.replace(/\s*/g, '');
console.log(str2); // 2323
```

2.  使用 str.trim()方法
    trim()方法有局限性，无法去除中间的空格

```
var str = "     xiao    ming    ";
var str2 = str.trim();
console.log(str2); // xiao    ming
```

同理，str.trimLeft()，str.trimRight()分别用于去除字符串左右空格

3.  使用 jQuery,$trim(str)方法同上，同样也无法去除中间的空格

## 如何获取浏览器 url 中查询字符串中的参数

测试地址：http://www.runoob.com/jquery/misc-trim.html?channelid=12333&name=xiaoming&age=23

```
function showWindowHref (){
  const Shref = window.location.href;
  const args = Shref.split('?');
  if(args[0] == Shref) return '';
  var arr = args[1].split('&');
  var obj = {};
  arr.forEach(item => {
    const arg = item.split('=')
    obj[arg[0]] = arg[1]
  })
  return obj;
}
var href = showWindowHref();
console.log(href['name'])
```

## js 字符串操作函数

* concat() 将两个或多个字符的文本组合起来，返回一个新字符串
* indexOf() 返回字符串中一个子串第一处出现的索引。如果没有匹配项，返回-1。
* charAt() 返回指定位置的字符。
* lastIndexOf() 返回字符串中一个子串最后一处出现的索引，如果没有匹配项，返回-1。
* match() 检查一个字符串是否匹配一个正则表达式
* substr() 返回从 string 的 startPos 位置，长度为 length 的字符串
* substring() 返回字符串的一个子串，传入参数是其实位置和结束位置
* slice() 提取字符串的一部分，并返回一个新字符串
* replace() 用来查找匹配一个正则表达式的字符串，然后使用新字符串代替匹配的字符串
* search() 执行一个正则表达式匹配查找。如果查找成功，返回字符串中匹配的索引值。否则返回-1
* split() 通过将字符串划分成子串，将一个字符串做成一个字符串数组

## 怎样添加、移除、移动、复制、创建、查找节点

* 创建新节点

```
createDocumentFragment() // 创建一个DOM片段
createElement() // 创建一个具体的元素
createTextNode() // 创建一个文本节点
```

* 添加、移除、替换、插入

```
appendChild() // 添加
removeChild() // 移除
replaceChild() // 替换
insertBefore() // 插入
```

* 查找

```
getElementByTagName() // 通过标签名称
getElementByName() // 通过元素的Name属性的值
getElementById() // 通过元素Id， 唯一性
```

## 写出三个使用 this 的典型应用

* 在 html 元素事件属性中使用

```
<input type="button" onclick="showInfo(this)" value="点击一下" />
```

* 构造函数

```
function Animal(name, color) {
  this.name = name;
  this.color = color;
}
```

* input 点击获取值

```
<input type="button" id="text" value="点击一下" />
<script>
  var btn = document.getElementById('text');
  btn.onclick = function(){
    alert(this.value); // 此处的this是按钮元素
  }
</script>
```

* apply()/call()求数组最值

```
var numbers = [5, 458, 120, -25];
var maxInNumbers = Math.max.apply(this, numbers);
console.log(maxInNumbers); // 458
var maxInNumbers = Math.max.call(this,5, 458 , 120 , -215);
console.log(maxInNumbers);  // 458
```

## 比较 typeof 与 instanceof

相同点： js 中 typeof 和 instanceof 常用来判断一个变量是否为空，或者是什么类型的。

1.  typeof 一般只能返回如下几个结果： number boolean string function object undefined
2.  typeof 来获取一个变量是否存在，如 if(typeof a !== "undefined"){alert("ok")},而不要去使用 if(a)因为如果 a 不存在则会出错。
3.  对于 Array，Null 等特殊对象使用 typeof 一律返回，这正是 typeof 的局限性。

instanceof 用于判断一个变量是否属于某个对象的实例。

```
var a = new Array();
alert(a instanceof Array); // true
alert(a instanceof Object); // true
```

如上，会返回 true，同时 alert(a instanceof Object) 也会返回 true;这是因为 Array 是 object 的子类。

```
function test(){};
var a = new test();
alert(a instanceof test)   // true
```

如下，得到的结果为‘N’,这里的 instanceof 测试的 object 是指 js 语法中的 object，不是指 dom 模型对象。

```
if (window instanceof Object){ alert('Y')} else {  alert('N');}  // 'N'
```

## 如何理解闭包

* 定义和用法：当一个函数的返回值是另一个函数，而返回的那个函数如果调用了其父函数内部的其他变量，如果返回的这个函数在外部被执行，就产生了闭包。
* 表现形式：使函数外部能够调用函数内部定义的变量
* 实例如下：
  1.  根据作用域的规则，底层作用域没有声明的变量，会向上一级找，找到就返回，没找到就一直找，直到 window 的变量，没有就返回 undefined。这里明显 count 是函数内部的 flag2 的那个 count
  ```
  var count = 10; // 全局作用域，标记为flag1
  function add(){
    var count = 0;
    return function (){
      count+=1;
      alert(count);
    }
  }
  var s = add()
  s(); //输出1
  s(); //输出2
  ```
* 变量的作用域

特点：

1.  函数内部可以读取函数外部的全局变量，在函数外部无法读取函数内的局部变量
2.  函数内部声明变量的时候，一定要使用 var 命令，不用的话其实是声明了一个全局变量。当然 let 也可以。

* 使用闭包的注意点

1.  滥用闭包，会造成内存泄露：由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在 IE 中可能导致内存泄漏。解决办法是，在退出函数之前，将不使用的局部变量全部删除掉。
2.  会改变复函数内部变量的值，所以，如果你把复函数当做对象使用，把闭包当做他的公用方法，把内部变量当做他的私有属性，这时一定要小心，不要随便改变复函数内部变量的值。

## 什么事跨域？跨域请求资源的方法有哪些？

* 什么是跨域由于路由器的同源策略，凡是发送请求 utl 的协议、域名、端口三者之间任意一与当前页面地址不同即为跨域。

  * 网络协议不同，如 http 协议访问 https 协议。

  * 端口不同，如 80 端口访问 8080 端口。

  * 域名不同，如 qianduanblog.com 访问 baidu.com。

  * 子域名不同，如 abc.qianduanblog.com 访问 def.qianduanblog.com。

  * 域名和域名对应 ip,如 www.a.com 访问 20.205.28.90.

* 跨域请求资源的方法

1.  proxy 代理

定义和用法：proxy 代理用于将请求发送给后台服务器，通过服务器来发送请求，然后将请求的结果传递给前端。

实现方法：通过 nginx 代理；

注意点：1、如果你代理的是 https 协议的请求，那么你的 proxy 首先需要信任该证书（尤其是自定义证书）或者忽略证书检查，否则你的请求无法成功。

2.  CORS 【Cross-Origin Resource Sharing】

定义和用法：是现代浏览器支持跨域资源请求的一种最常用的方式。

使用方法：一般需要后端人员在处理请求数据的时候，添加允许跨域的相关操作。如下：

```
res.writeHead(200, {
    "Content-Type": "text/html; charset=UTF-8",
    "Access-Control-Allow-Origin":'http://localhost',
    'Access-Control-Allow-Methods': 'GET, POST, OPTIONS',
    'Access-Control-Allow-Headers': 'X-Requested-With, Content-Type'
});
```

3.  jsonp

定义和用法：通过动态插入一个 script 标签。浏览器对 script 的资源引用没有同源限制，同时资源加载到页面后会立即执行（没有阻塞的情况下）。

特点：通过情况下，通过动态创建 script 来读取他域的动态资源，获取的数据一般为 json 格式。

```
<script>
    function testjsonp(data) {
       console.log(data.name); // 获取返回的结果
    }
</script>
<script>
    var _script = document.createElement('script');
    _script.type = "text/javascript";
    _script.src = "http://localhost:8888/jsonp?callback=testjsonp";
    document.head.appendChild(_script);
</script>
```

缺点：

1.  这种方式无法发送 post 请求（这里）

2.  另外要确定 jsonp 的请求是否失败并不容易，大多数框架的实现都是结合超时时间来判定。

## 谈谈垃圾回收机制及内存管理

回收机制方式

1.  定义：垃圾回收机制，执行环境负责管理代码执行过程中使用的内存。
2.  原理：垃圾收集器(周期性)会定期找出那些不再继续适用的变量，然后释放其内存。但是这个过程不是实时的，因为其开销大，所以垃圾回收器会按照固定的时间间隔周期性执行。
3.  实例：

```
function fn1 (){
  var obj = { name: 'hahaha', age: 10};
}
function fn2 (){
  var obj = { name: 'hahaha', age: 10};
  return obj;
}
var a = fn1();
var b = fn2();
```

fn1 中定义的 obj 为局部变量，而当调用结束后，出了 fn1 的环境，那么该内存会被 js 引擎中的垃圾回收器自动释放；在 fn2 被调用的过程中，返回的对象呗全局变量 b 所指向，所以该快内存并不会被释放。

1.  标记回收策略： 标记清除(较为常用)和引用计数。

标记清除：

定义和用法：当变量进入环境时，将变量标记“进入环境”，当变量离开环境时，比较为：“离开环境”。某一个时刻，垃圾回收器会过滤掉环境中的变量，以及被环境变量引用的变量，剩下的就是被视为准备回收的变量。

到目前为止 IE，Firefox，opera，chrome，Safari 实现使用的都是标记清除的垃圾回收策略或类似的策略，只不过垃圾收集的时间间隔互不相同。

引用计数：

定义和用法：引用计数是跟踪记录每个值被引用的次数。基本原理：就是变量的引用次数，被引用一次则加一，当这个引用计数为 0 时，被视为准备回收的对象。

内存管理：

什么时候触发垃圾回收？

1.  垃圾回收器周期性运行，如果分配的内存非常多，那么回收工作也会很艰巨，确定垃圾回收时间间隔就变成了一个值得思考的问题。

IE6 的垃圾回收是根据内存分配量运行的，当环境中的变量，对象，字符串达到一定数量时触发垃圾回收。垃圾回收器一直处于工作状态，严重影响浏览器性能。

IE7 中，垃圾回收器会根据内存分配量与程序占用内存的比例进行动态调整，开始回收工作。

2.  合理的 GC 方案： (1) 遍历所有可访问的对象；(2) 回收已不可访问的对象。
3.  GC 缺陷： (1) 停止响应其他操作。
4.  GC 优惠策略：(1) 分代回收(Generation GC);(2) 增量 GC；

## 开发过程中遇见的内存泄漏情况，如何解决的？

1.  定义：

内存泄漏是指一块被分配的内存既不能使用，又不能回收，知道浏览器进程结束。C#和 JAVA 等语言采用了自动垃圾回收方法管理内存，机会不会发生内存泄露。我们知道，浏览器中也是采用自动垃圾回收方法管理内存，但由于浏览器垃圾回收方法有 bug，会产生内存泄露。

2.  内存泄漏的几种情况：

1.  当页面中的元素被移除或替换时，若元素绑定的事件仍没被移除，在 IE 中不会做出恰当处理，此时要先手工移除事件，不然会存在内存泄漏。

```
<div id="myDiv">
  <input type="button" value="Click me" id="myBtn" />
</div>
<script>
  var btn = document.getElementById("myBtn")
  btn.onclick = function () {
    document.getElementById("myDiv").innerHTMl = "processing...";
  }
</script>
```

解决方法是：

```
<div id="myDiv">
  <input type="button" value="Click me" id="myBtn" />
</div>
<script>
  var btn = document.getElementById("myBtn")
  btn.onclick = function () {
    btn.onclick = null;
    document.getElementById("myDiv").innerHTMl = "processing...";
  }
</script>
```

2.  由于是函数内定义函数，并且内部函数--时间回调的引用外暴了，形成了闭包。闭包可以维持函数内局部变量，使其得不到释放。

```
function btnEvent(){
  var obj = document.createElement('XXX');
  obj.onclick = function () {
    // Even if it's a empty function
  }
}
```

解决方法：

```
function bindEvent(){
    var obj=document.createElement("XXX");
    obj.onclick=function(){
         //Even if it's a empty function
    }
    obj=null;
}
```

## JavaScript 面向对象中继承实现？

面向对象的基本特诊有：封闭，继承，多态。

在 JavaScript 中实现继承的方法：

1.  原型链(prototype chaining)
2.  call()/apply()
3.  混合方式(prototype 和 call()/apply()结合)
4.  对象冒充

继承方法：

1.  proto 原型链方式：

```
function teacher(name) {
  this.name = name;
}
teacher.prototype.sayName = function(){
  console.log("name is" + this.name);
}
var teacher1 = new teacher("xiaoming");
teacher1.sayName();

function student(name) {
  this.name = name;
}
student.prototype = new teacher();
var student1 = new student("xiaolan");
student1.sayName();
// name is xiaoming
// name is xiaolan
```

2.  call()/apply()方法

```
function teacher(name, age) {
  this.name = name;
  this.age = age;
  this.sayhi = function () {
    alert('name' + name + ", age:" + age);
  }
}
function student () {
  var args = arguments;
  teacher.call(this, args[0], args[1]);
  // teacher.apply(this, arguments);
}

var teacher1 = new teacher('xiaoming', 23);
teacher1.sayhi();

var student1 = new student('xiaolan', 12);
student1.sayhi();

// alert: name:xiaoming, age: 23;
// alert: name:xiaolan, age: 12;
```

3.  混合方法[prototype, call/apply]

```
  function teacher(name, age) {
    this.name = name;
    this.age = age;
  }
  teacher.prototype.sayName = function (){
    console.log('name' + this.name);
  }
  teacher.prototype.sayAge = function(){
    console.log('age' + this.age);
  }
  function student() {
    var args = arguments;
    teacher.call(this, args[0], args[1]);
  }
  student.prototype = new teacher();

  var student1 = new student('xiaolin', 23);
  student1.sayName();
  student1.sayAge();
  // name:xiaolin
  // age:23
```

4.  对象冒充

```
function Person(name, age) {
  this.name = name;
  this.age = age;
  this.show = function (){
    console.log(this.name + ", " + this.age);
  }
}

function Student(name, age) {
  this.student = Person; // 将Person类的构造函数赋值给this.student
  this.student(name, age); // js中实际上是通过对象冒充来实现继承的
  delete this.student;
}

var S = new Student("小明", 17);
s.show();

var P = new Person("小花", 18);
p.show();
// 小明，17
// 小花，18
```

# JavaScript 相关程序计算题

## 判断一个字符串中出现次数最多的字符，统计这个次数

```
var str = "asdfssaaasasasasaa";
var json = {};
for(let i = 0;i < str.length;i++){
  if (!json[str.charAt(i)]) {
    json[str.charAt(i)] = 1;
  }else {
    json[str.charAt(i)]++;
  }
}
var iMax = 0;
var iIndex = '';
for(var i in json){
  if(json[i]>iMax){
    iMax = json[i];
    iIndex = i;
  }
}

console.log('出现次数最多的是：' + iIndex + '出现' +  iMax + '次')

// 出现次数最多的是：a出现9次
```

# JavaScript 数组对象

## Array 相关的属性和方法

Array 对象属性

constructor 返回对创建此对象的数组函数的引用

```
var test = new Array()

if(test.constructor == Array) {
  console.log("this is an Array");
}
if(test.constructor == Boolean) {
  console.log("this is a Boolean");
}
if(test.constructor == Date) {
  console.log("this is a Date");
}
if(test.constructor == String) {
  console.log("this is a String");
}
```

Array 对象方法

concat()连接两个或更多的数组，并返回结果。

```
var arr = [1,2,3,4];
var arr2 = [5,6,7,8];
var arr3 = arr.concat(arr2);
console.log(arr3); // [1, 2, 3, 4, 5, 6, 7, 8]
```

join()把数组的所有元素放入一个字符串。元素通过指定的分隔符进行分割。

```
var arr = ['xiao','lin','qiqi','mingtian'];
var arr2 = arr.join(',');
console.log(arr2); // 根据','隔开返回的字符串为："xiao,lin,qiqi,mingtian"
```

pop()删除并返回数组的最后一个元素

```
var arr = [2,3,4,5];
var arr2 = arr.pop();
console.log(arr2); // 删除的数组的最后一个元素为：5
console.log(arr); // 删除元素之后的数组为： [2,3,4]
```

shift() 删除并返回数组的第一个元素

```
var arr = [2,3,4,5];
var arr2 = arr.shift();
console.log(arr2); // 删除的数组的第一个元素为：2
console.log(arr);  // 删除元素之后的数组为：[3, 4，5]
```

push() 向数组的末尾添加一个或更多元素，并返回新的长度。

```
var arr = [2,3,4,5];
var arr2 = arr.push(6);
console.log(arr2);  // 返回的数组长度：5
console.log(arr);  // [2, 3, 4, 5, 6]
```

unshift() 向数组的开头添加一个或更多元素，并返回新的长度。

```
var arr = ['xiao','ming','qiqi','aiming'];
var arr1 = arr.unshift('lang');
console.log(arr1);  // 返回的数组的长度：  5
console.log(arr);  //向数组开头添加元素返回的结果：["lang", "xiao", "ming", "qiqi", "aiming"]
```

reverse() 颠倒数组中元素的顺序。

```
var arr = [2,3,4,5];
arr.reverse();
console.log(arr);   //  [5, 4, 3, 2]
```

slice() 从某个已有的数组返回选定的元素

```
var arr = [2,3,4,5];
var arr2 = arr.slice(1,3);
console.log(arr2);  // 截取区间返回的数组为：[3, 4]
console.log(arr);  // [2, 3, 4, 5]
```

sort() 对数组的元素进行排序

```
借助排序函数，实现数值由小到大排序
function sortNumber(a,b){
    return a - b
}
var arr = [23,30,42,5];
var arr2 = arr.sort(sortNumber);
console.log(arr2);  // [5, 23, 30, 42]
console.log(arr);   // [5, 23, 30, 42]

借助排序函数，实现数值由大到小排序
function sortNumber(a,b){
    return b - a
}
var arr = [23,30,42,5];
var arr2 = arr.sort(sortNumber);
console.log(arr2);  // [42, 30, 23, 5]
console.log(arr);  // [42, 30, 23, 5]
```

splice() 删除元素，并向数组添加新元素。

```
语法:arrayObject.splice(index,howmany,item1,.....,itemX)
index:必需。整数，规定添加/删除项目的位置，使用负数可从数组结尾处规定位置。
howmany:必需。要删除的项目数量。如果设置为 0，则不会删除项目。
item1, ..., itemX:可选。向数组添加的新项目。

// 创建一个新数组，并向其添加一个元素
var arr = [1,2,3,4];
arr.splice(2,0,5);
console.log(arr);  // [1, 2, 5, 3, 4]

// 删除位于 index 2 的元素，并添加一个新元素来替代被删除的元素：
var arr = [1,2,3,4];
arr.splice(2,1,5);
console.log(arr);  // [1, 2, 5, 4]
```

toSource() 返回该对象的源代码。

```
浏览器支持
只有 Gecko 核心的浏览器（比如 Firefox）支持该方法，也就是说 IE、Safari、Chrome、Opera 等浏览器均不支持该方法。
<script type="text/javascript">
function employee(name,job,born){
    this.name=name;
    this.job=job;
    this.born=born;
}
var bill = new employee("Bill Gates","Engineer",1985);
document.write(bill.toSource());
</script>
输出：({name:"Bill Gates", job:"Engineer", born:1985})
```

toString() 把数组转换为字符串，并返回结果。

```
var arr = ['xiao','ming','qiqi','aiming'];
arr.toString();
console.log(arr);  // ["xiao", "ming", "qiqi", "aiming"]
```

toLocaleString() 把数组转换为本地数组，并返回结果。

```
var arr = ['xiao','ming','qiqi','aiming'];
arr.toLocaleString();
console.log(arr);  // ["xiao", "ming", "qiqi", "aiming"]
```

valueOf() 返回数组对象的原始值

```
var arr = ['xiao','ming','qiqi','aiming'];
arr.valueOf('lang');
console.log(arr); // ["xiao", "ming", "qiqi", "aiming"]
```

## 数组去重

```
var arr = [0,2,3,4,4,0,2];
var obj = {};
var tmp = [];
for(var i =0;i<arr.length;i++){
  if(!obj[arr[i]]){
    obj[arr[i]] = 1;
    tmp.push(arr[i]);
  }
}
console.log(tmp); // [0, 2, 3, 4]
```

```
var arr = [2,3,4,4,5,2,3,6],
   arr2 = [];
for(var i = 0;i< arr.length;i++){
    if(arr2.indexOf(arr[i]) < 0){
        arr2.push(arr[i]);
    }
}
console.log(arr2);
```

```
var arr = [2,3,4,4,5,2,3,6];
var arr2 = arr.filter(function(element,index,self){
return self.indexOf(element) === index;
});
console.log(arr2);
```

## 求数组的最值

```
求数组最大值:Math.max.apply(null,arr);
var arr = [3,43,23,45,65,90];
var max = Math.max.apply(null,arr);
console.log(max);
// 90
求数组最小值：Math.min.apply(null,arr);
var arr = [3,43,23,45,65,90];
var min = Math.min.apply(null,arr);
console.log(min);
// 3
```

方法二：Array.max = function(arr){} / Array.min = function(arr){}

```
var array = [3,43,23,45,65,90];

Array.max = function( array ){
   return Math.max.apply( Math, array );
};
Array.min = function( array ){
   return Math.min.apply( Math, array );
};

var max = Array.max(array);
console.log(max);  // 90

var min = Array.min(array);
console.log(min);  // 3
```
